
static void 
cast_sample_rays(CastState *state)
{
    World *world = state->world;
    u32    rays_per_pixel = state->rays_per_pixel;
    u32    max_bounce_count = state->max_bounce_count;
    Vec3 camera_pos = state->camera_pos;
    Vec3 camera_x = state->camera_x;
    Vec3 camera_y = state->camera_y;
    Vec3 camera_z = state->camera_z;
    f32 film_w = state->film_w;
    f32 film_h = state->film_h;
    f32 half_film_w = state->half_film_w;
    f32 half_film_h = state->half_film_h;
    Vec3 film_center = state->film_center;
    f32 half_pix_w = state->half_pix_w;
    f32 half_pix_h = state->half_pix_h;
    RandomSeries series = state->series;
    f32 film_x = state->film_x;
    f32 film_y = state->film_y;
    Vec4 final_color      = vec4(0, 0, 0, 1);
    u64  bounces_computed = 0;
    
    u32 lane_width = LANE_WIDTH;
    u32 lane_ray_count = rays_per_pixel / lane_width;
    f32 contrib = reciprocal32(lane_ray_count);
    for (u32 ray_index = 0;
        ray_index < lane_ray_count;
        ++ray_index)
    {
        f32 off_x = film_x + random_bilateral(&series) * half_pix_w;
        f32 off_y = film_y + random_bilateral(&series) * half_pix_h;
        Vec3 film_pos = vec3_add(film_center,
            vec3_add(vec3_muls(camera_x, off_x * half_film_w),
                vec3_muls(camera_y, off_y * half_film_h)));
        Vec3 ray_origin = camera_pos;
        Vec3 ray_dir    = vec3_normalize(vec3_sub(film_pos, camera_pos));

        Vec4 ray_cast_color = vec4(0, 0, 0, 1);

        Ray ray;
        ray.origin = ray_origin;
        ray.dir    = ray_dir;

        f32 min_hit_distance = 0.0001f;
        f32 tolerance = 0.0001f;

        Vec4 attenuation = vec4(1, 1, 1, 1);

        for (u32 bounce_count = 0;
            bounce_count < 8;
            ++bounce_count)
        {
            ++bounces_computed;

            f32 hit_distance = F32_MAX;

            u32 hit_mat_index = 0;
            Vec3 next_normal = { 0 };

            for (u32 plane_index = 0;
                plane_index < world->plane_count;
                ++plane_index)
            {
                Plane plane = world->planes[plane_index];

                f32 denominator = vec3_dot(plane.normal, ray.dir);
                if ((denominator < -tolerance) >(denominator > tolerance))
                {
                    f32 t = (-plane.dist - vec3_dot(plane.normal, ray.origin)) / denominator;
                    if ((t > min_hit_distance) && (t < hit_distance))
                    {
                        hit_distance = t;
                        hit_mat_index = plane.mat_index;

                        next_normal = plane.normal;
                    }
                }
            }

            for (u32 sphere_index = 0;
                sphere_index < world->sphere_count;
                ++sphere_index)
            {
                Sphere sphere = world->spheres[sphere_index];

                Vec3 sphere_relative_ray_origin = vec3_sub(ray.origin, sphere.pos);
                f32 a = vec3_dot(ray.dir, ray.dir);
                f32 b = 2.0f * vec3_dot(sphere_relative_ray_origin, ray.dir);
                f32 c = vec3_dot(sphere_relative_ray_origin, sphere_relative_ray_origin) - square(sphere.radius);

                f32 denominator = 2.0f * a;
                f32 root_term = sqrt32(square(b) - 4.0f * a * c);

                if (root_term > tolerance)
                {
                    f32 tp = (-b + root_term) / denominator;
                    f32 tn = (-b - root_term) / denominator;

                    f32 t = tp;
                    if ((tn > min_hit_distance) && (tn < tp))
                    {
                        t = tn;
                    }

                    if ((t > min_hit_distance) && (t < hit_distance))
                    {
                        hit_distance = t;
                        hit_mat_index = sphere.mat_index;

                        next_normal = vec3_normalize(vec3_add(sphere_relative_ray_origin, vec3_muls(ray.dir, hit_distance)));
                    }
                }
            }

            if (hit_mat_index)
            {
                Material mat = world->materials[hit_mat_index];

                ray_cast_color  = vec4_add(ray_cast_color, vec4_mul(attenuation, mat.emit_color));
                f32 cos_atten = vec3_dot(vec3_neg(ray.dir), next_normal);
                if (cos_atten < 0) cos_atten = 0;
                attenuation = vec4_mul(attenuation, vec4_muls(mat.reflect_color, cos_atten));

                ray.origin = ray_point_at(ray, hit_distance);

                Vec3 pure_bounce = vec3_reflect(ray.dir, next_normal);
                Vec3 random_bounce = vec3_normalize(vec3_add(next_normal,
                    vec3(random_bilateral(&series), random_bilateral(&series), random_bilateral(&series))));
                ray.dir = vec3_normalize(vec3_lerp(random_bounce, pure_bounce, mat.scatter));
            }
            else
            {
                Material mat = world->materials[hit_mat_index];
                ray_cast_color = vec4_add(ray_cast_color, vec4_mul(attenuation, mat.emit_color));
                break;
            }
        }

        final_color = vec4_add(final_color, vec4_muls(ray_cast_color, contrib));
        ++bounces_computed;
    }

    final_color = vec4_muls(vec4(linear_to_srgb(final_color.x), 
                                 linear_to_srgb(final_color.y),
                                 linear_to_srgb(final_color.z),
                                 1), 255.0f);
    state->bounces_computed += bounces_computed;
    state->final_color = final_color;
}
